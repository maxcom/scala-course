<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Базовые примитивы многопоточности</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h2>Часть 5. Базовые примитивы многопоточности</h2>
					<p><small>Страничка курса: <a href="https://maxcom.github.io/scala-course/">https://maxcom.github.io/scala-course/</small></a>
				</section>

				<section>
					<h3>План</h2>
					<ol>
						<li>Поток, пулы потоков. 
						<li>Синхронизация, блокировки и атомики. 
						<li>Future и Promise. 
						<li>Реализация map, sequence и других функций стандартной библиотеки. 
						<li>for-нотация для Future.
					</ol>
				</section>
				<section>
					<h3>Потоки выполнения</h2>

					<ul>
						<li>Каждый поток выполняется процессором независимо.
						<li>Все потоки работают в общем адресном пространстве, но имеют свои стеки.
						<li>Процессор переключается между разными потоками.
						<li>В многоядерных системах потоки выполняются одновременно.
					</ul>
				</section>
				<section>
					Потоки применяют для:
					<ul>
						<li>Выполнения программы более чем на одном ядре CPU.
						<li>Параллельного выполнения разных процессов программы.
					</ul>
				</section>
				<section>
					<p>В серверных проложениях часто выделяют по потоку каждому клиенту.</p>

					<p>Программисту это удобно, но не всегда эффективно. В 7-й лекции
					поговорим об устройстве высоконагруженных приложений.</p>
				</section>
				<section>
					Создание потока - часть Java Runtime:
					<pre><code class="scala">
val thread = new Thread(() => {
  println("Hello world!")
})	

thread.start()
					</code></pre>

				</section>

				<section>
					<h3>Пулы потоков</h3>
					<p>Явно потоки (почти) никогда не нужно создавать:
					<ul>
						<li>создание потока - "дорогая" операция
						<li>потоков не должно быть много
					</ul>
				</section>

				<section>
					<h4>Сколько должно быть потоков?</h4>
					<ul>
						<li>под математику: число ядер
						<li>сетевое взаимодействие и простая логика без блокирующих 
							вызовов: N * CPU, N ~= 3
						<li>дисковый ввод-вывод: число шпинделей жесткого диска
						<li>и т. п.
					</ul>
					Верхняя граница у современных ОС - порядка 1000 нитей на процесс. Дальше не
					эффективно.
				</section>

				<section>
					Пул потоков создается один раз

					<pre><code class="scala">
// используем Java API
val executor: ExecutorService =
  Executors.newFixedThreadPool(10) // 10 потоков

// создаем Scala-обертку
implicit val ec: ExecutionContextExecutor =
  ExecutionContext.fromExecutor(executor)
					</code></pre>
				</section>

				<section>
					<p>Задачи можно передать так:
					<pre><code class="scala">
ec.execute(() =&gt; {
  println("Hello world!")
})
					</code></pre>
				</section>

				<section>
					<h3>Синхронизация, блокировки и атомики.</h3>
					Потокам нужно взаимодействовать: нужно координировать доступ
					к разделяемым ресурсам - памяти, сокетам, файлам и т.п.
				</section>

				<section>
					Модель исполнения и памяти сложнее чем кажется:
					<ul>
						<li>Процессор, компилятор и JVM меняют реальный порядок выполения
						<li>Кеши процессоров сами не синхронизируются
					</ul>
					Нужны специальные "барьеры" в точках взаимодействия.
				</section>
				
				<section>
					Общие ресурсы требуют последовательного доступа - пока один поток
					выполняется другие его ждут.
				</section>

				<section>
					<h4>Синхронизация из Java</h4>
					<pre><code style="scala">
val lock = new Object()

var counter: Int = 0

lock.synchronized {
  counter += 1
}					
					</code></pre>
				</section>

				<section>
					В Java SDK есть много других вариантов: с поддержкой таймаута, блокировки,
					latch, семафоры и т.п.
				</section>

				<section>
					<h4>Deadlock</h4>
					<p>Если брать lock'и в разном порядке в разных потоках можно получить взаимную
					блокировку, из которой не выйти.
				</section>

				<section>
					<h3>volatile</h3>
					volatile переменная - только барьер, без блокировок.
					<pre><code style="scala">
@volatile var vcounter: Int = 0	
					</code></pre>
					операции над ней "упорядочены", но защиты от "гонки потоков" нет
				</section>

				<section>
					<h3>Atomic</h3>
					<p>Специальная инструкция процессора - CompareAndSet (CAS)
					<p>Меняет значение на новое если старое равно заданному</p>
					<p>Потокобезопасно
				</section>

				<section>
					Atomic счетчик работает без блокировок:
<pre><code class="java">
// реализация из исходников JDK; Java
public final int incrementAndGet() {
    for (;;) {
        int current = get();
        int next = current + 1;
        if (compareAndSet(current, next))
            return next;
    }
}
</code></pre>			
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                controls: true,
                                progress: true,
                                history: true,
                                center: true,

                                transition: 'slide', // none/fade/slide/convex/concave/zoom

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
