<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Implicit значения и преобразования. Тайпклассы. Чтение и запись JSON в play-json.</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Часть 4. Implicit значения и преобразования. Тайпклассы. Чтение и запись JSON в play-json.</h3>
					<p><small>Страничка курса: <a href="https://maxcom.github.io/scala-course/">https://maxcom.github.io/scala-course/</small></a>
				</section>

				<section>
					<h3>План</h3>
					<ol>
						<li>Imlicit значения
						<li>Передача контекста и конфигурации; 
						<li>“pimp my library”. 
						<li>Тайпклассы
						<li>Сериализация и type classes на примере Play-JSON
						<li>Практическая часть: разбор JSON из API vk.com.
						<li>Дополнительная часть: property based testing.
					</ol>
				</section>

				<section>
					<p>"Неявные" значения и преобразования - последная
					конструкция Scala, которую мы рассмотрим на этом курсе.
				</section>

				<section>
					<p>Implicit'ы имеют огромное количество способов
					испрльзования, рассмотрим несколько популярных
				</section>

				<section>
					<p>Дополнительный блок параметров функции
					<pre><code class="scala">
def getUser(id: Int)(implicit session: DatabaseSession): User
					</code></pre>
					<p>значения которого можно явно не задавать
				</section>

				<section>
					<p>Значение должно существовать в области видимости
					<pre><code class="scala">
localTx { implicit session ⇒ 
  getUser(10)
}					
					</code></pre>
				</section>

				<section>
					<p>Где это применяется? Для передачи контекста
					<ul>
						<li>Сессия/транзакция БД
						<li>Конфигурация
						<li>Свойства пользователя (права, язык, таймзона и т.п.)
						<li>...
					</ul>
				</section>

				<section>
					<p>Без implicit значения пришлось бы
					<ul>
						<li>Явно передавать значения
						<li>Передавать неявно через thread local и "магию" фреймворков
					</ul>
				</section>

				<section>
					<p>implicit значения ищутся в
					<ul>
						<li>Объявлениях в текущем контексте
						<li>В import'ах - значала в точных, потом в wildcard
						<li>В companion object связанных типов
					</ul>
				</section>

				<section>
					<p>Неоднозначности в поиске - ошибка компиляции
				</section>

				<section>
					<h4>Неявные классы</h4>
				</section>

				<section>
					<p>Преобразование одного класса в другой
					<pre><code class="scala">
implicit class RichString(str: String)
					</code></pre>
					<p>автоматическое преобразование там где необходимо
				</section>

				<section>
					<p>"Pimp my library" - прием из динамических языков, например Ruby
				</section>

				<section>
					<p>В Ruby код может "улучшить" любой класс, даже стандартную библиотеку
					
					<p class="fragment">Это называется "Monkey patch", и является опасной техникой
				</section>

				<section>
					<p>Опасности:
					<ul>
						<li>Нарушение инкапсуляции
						<li class="fragment">Проблемы при обновлении - неявные зависимости на реализацию
						<li class="fragment">Конфликты разных "улучшателей"
						<li class="fragment">Сложности отладки
					</ul>
				</section>

				<section>
					<p>Implicit class - безопасная замена этой техники
				</section>

				<section>
					<p>Пример - добавляем метод в String
					<pre><code class="scala">
implicit class RichString(str: String) {
  def letters = str.count(_.isLetter)
}

"scala 2.12".letters // = 5
					</code></pre>
				</section>

				<section>
					<p>В отличие от monkey patching
					<ul>
						<li>Разрешается в процессе компиляции
						<li>Не влияет на существующий код
					</ul>
				</section>

				<section>
					<p>Более правильная версия примера:
					<pre><code class="scala">
implicit class RichString(val str: String) extends AnyVal {
  def letters = str.count(_.isLetter)
}
					</code></pre>
					<p><small>класс существует только в compile time</small>
				</section>

				<section>
					<p>Технику применяют для "красоты", например:
					<pre><code class="scala">
import scala.concurrent.duration._

val timeout: Duration = 5 minutes
// замена Duration(5, TimeUnit.MINUTES)
					</code></pre>
					<p><small>еще пример - specs2</small>
				</section>

				<section>
					<h4>Неявные преобразования</h4>
				</section>

				<section>
					<p>Неявная функция преобразования

					<pre><code class="scala">
class RichString(val str: String) extends AnyVal {
  def letters = str.count(_.isLetter)
}

implicit def str2rich(str: String): RichString = 
  new RichString(str)

"scala 2.12".letters
					</code></pre>
					<p><small>implicit функции могут иметь implicit параметры</small>
				</section>

				<section>
					<h4>Тайпклассы</h4>
				</section>

				<section>
					<p>Type class - шаблон проектирования, построенный на
					использовании implicit преобразований.

					<p class="fragment">Рассмотрим его на примере работы с JSON
				</section>

				<section>
					<h4>JSON</h4>
					<p>Текстовый формат обмена данными.
					<p class="fragment">Пришел на замену XML, который оказался
					слишком сложным и слишком медленным.
				</section>

				<section>
					<p>Использует синтаксис объявления данных JavaScript
					<pre><code class="json">
{
   "firstName": "Иван",
   "lastName": "Иванов",
   "address": {
       "streetAddress": "Московское ш., 101, кв.101",
       "city": "Ленинград",
       "postalCode": 101101
   },
   "phoneNumbers": [
       "812 123-1234",
       "916 123-4567"
   ]
}					
					</code></pre>
				</section>

				<section>
					<p>Формально описан в <a target="_blank" href="https://trac.tools.ietf.org/html/rfc8259">rfc8259</a>

					<p>Весь стандарт - 16 страниц текста, включая оглавления, ссылки и т.п.
				</section>

				<section>
					<p>Json легко читается (если отформатировать); библиотеки для работы с ним есть
					для большинства языков программирования.
				</section>

				<section>
					<p>TODO: еще история
				</section>

				<section>
					<h4>Запись JSON
					<p>TODO
				</section>

				<section>
					<h4>Чтение JSON и валидация
					<p>TODO
				</section>

				<section>
					<h4>Домашнее задание
					<p>TODO
				</section>

				<section>
					<h4>Доп: property based testing
					<p>TODO
				</section>

				<section>
					<p>Напоминаю:
					<ul>
						<li>Страничка курса: <a href="https://maxcom.github.io/scala-course/">https://maxcom.github.io/scala-course/</a>
						<li>Посещения - отмечаем на листочке
					</ul>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                controls: true,
                                progress: true,
                                history: true,
                                center: true,

                                transition: 'slide', // none/fade/slide/convex/concave/zoom

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
