<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Implicit значения и преобразования. Тайпклассы. Чтение и запись JSON в play-json.</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Часть 4. Implicit значения и преобразования. Тайпклассы. Чтение и запись JSON в play-json.</h3>
					<p><small>Страничка курса: <a href="https://maxcom.github.io/scala-course/">https://maxcom.github.io/scala-course/</small></a>
				</section>

				<section>
					<h3>План</h3>
					<ol>
						<li>Imlicit значения
						<li>Передача контекста и конфигурации; 
						<li>“pimp my library”. 
						<li>Тайпклассы
						<li>Сериализация и type classes на примере Play-JSON
						<li>Практическая часть: разбор JSON из API vk.com.
						<li>Дополнительная часть: property based testing.
					</ol>
				</section>

				<section>
					<p>"Неявные" значения и преобразования - последная
					конструкция Scala, которую мы рассмотрим на этом курсе.
				</section>

				<section>
					<p>Implicit'ы имеют огромное количество способов
					испрльзования, рассмотрим несколько популярных
				</section>

				<section>
					<p>Дополнительный блок параметров функции
					<pre><code class="scala">
def getUser(id: Int)(implicit session: DatabaseSession): User
					</code></pre>
					<p>значения которого можно явно не задавать
				</section>

				<section>
					<p>Значение должно существовать в области видимости
					<pre><code class="scala">
localTx { implicit session ⇒ 
  getUser(10)
}					
					</code></pre>
				</section>

				<section>
					<p>Где это применяется? Для передачи контекста
					<ul>
						<li>Сессия/транзакция БД
						<li>Конфигурация
						<li>Свойства пользователя (права, язык, таймзона и т.п.)
						<li>...
					</ul>
				</section>

				<section>
					<p>Без implicit значения пришлось бы
					<ul>
						<li>Явно передавать значения
						<li>Передавать неявно через thread local и "магию" фреймворков
					</ul>
				</section>

				<section>
					<p>implicit значения ищутся в
					<ul>
						<li>Объявлениях в текущем контексте
						<li>В import'ах - значала в точных, потом в wildcard
						<li>В companion object связанных типов
					</ul>
				</section>

				<section>
					<p>Неоднозначности в поиске - ошибка компиляции
				</section>

				<section>
					<h4>Неявные классы</h4>
				</section>

				<section>
					<p>Преобразование одного класса в другой
					<pre><code class="scala">
implicit class RichString(str: String)
					</code></pre>
					<p>автоматическое преобразование там где необходимо
				</section>

				<section>
					<p>"Pimp my library" - прием из динамических языков, например Ruby
				</section>

				<section>
					<p>В Ruby код может "улучшить" любой класс, даже стандартную библиотеку
					
					<p class="fragment">Это называется "Monkey patch", и является опасной техникой
				</section>

				<section>
					<p>Опасности:
					<ul>
						<li>Нарушение инкапсуляции
						<li class="fragment">Проблемы при обновлении - неявные зависимости на реализацию
						<li class="fragment">Конфликты разных "улучшателей"
						<li class="fragment">Сложности отладки
					</ul>
				</section>

				<section>
					<p>Implicit class - безопасная замена этой техники
				</section>

				<section>
					<p>Пример - добавляем метод в String
					<pre><code class="scala">
implicit class RichString(str: String) {
  def letters = str.count(_.isLetter)
}

"scala 2.12".letters // = 5
					</code></pre>
				</section>

				<section>
					<p>В отличие от monkey patching
					<ul>
						<li>Разрешается в процессе компиляции
						<li>Не влияет на существующий код
					</ul>
				</section>

				<section>
					<p>Более правильная версия примера:
					<pre><code class="scala">
implicit class RichString(val str: String) extends AnyVal {
  def letters = str.count(_.isLetter)
}
					</code></pre>
					<p><small>класс существует только в compile time</small>
				</section>

				<section>
					<p>Технику применяют для "красоты", например:
					<pre><code class="scala">
import scala.concurrent.duration._

val timeout: Duration = 5 minutes
// замена Duration(5, TimeUnit.MINUTES)
					</code></pre>
					<p><small>еще пример - specs2</small>
				</section>

				<section>
					<h4>Неявные преобразования</h4>
				</section>

				<section>
					<p>Неявная функция преобразования

					<pre><code class="scala">
class RichString(val str: String) extends AnyVal {
  def letters = str.count(_.isLetter)
}

implicit def str2rich(str: String): RichString = 
  new RichString(str)

"scala 2.12".letters
					</code></pre>
					<p><small>implicit функции могут иметь implicit параметры</small>
				</section>

				<section>
					<h4>Тайпклассы</h4>
				</section>

				<section>
					<p>Type class - шаблон проектирования, построенный на
					использовании implicit преобразований.

					<p class="fragment">Рассмотрим его на примере работы с JSON
				</section>

				<section>
					<h4>JSON</h4>
					<p>Текстовый формат обмена данными.
					<p class="fragment">Пришел на замену XML, который оказался
					слишком сложным и слишком медленным.
				</section>

				<section>
					<p>Использует синтаксис объявления данных JavaScript
					<pre><code class="json">
{
   "firstName": "Иван",
   "lastName": "Иванов",
   "address": {
       "streetAddress": "Московское ш., 101, кв.101",
       "city": "Ленинград",
       "postalCode": 101101
   },
   "phoneNumbers": [
       "812 123-1234",
       "916 123-4567"
   ]
}					
					</code></pre>
				</section>

				<section>
					<p>Формально описан в <a target="_blank" href="https://trac.tools.ietf.org/html/rfc8259">rfc8259</a>

					<p>Весь стандарт - 16 страниц текста, включая оглавления, ссылки и т.п.
				</section>

				<section>
					<p>Json легко читается (если отформатировать)

					<p class="fragment">Библиотеки для работы с ним есть
					для большинства языков программирования.
				</section>

				<section>
					<p>Формат JSON был разработан<br>Дугласом Крокфордом.
					<p>Видео: <a target="_blank" href="https://www.youtube.com/watch?v=-C-JoyNuQJs">The JSON Saga</a>
				</section>

				<section>
					<p>Используем библиотеку Play JSON.

					<p>Часть play-framework; можно использовать отдельно.
				</section>

				<section>
					<p>Документация:
					<ul>
						<li><a target="_blank" href="https://www.playframework.com/documentation/2.6.x/ScalaJson">JSON Basics</a>
						<li><a target="_blank" href="https://www.playframework.com/documentation/2.6.x/ScalaJsonCombinators">JSON Reads/Writes/Format Combinators</a>
						<li><a target="_blank" href="https://www.playframework.com/documentation/2.6.x/ScalaJsonAutomated">JSON automated mapping</a>
					</ul>
				</section>

				<section>
					<p>Подключаем библиотеку в проект

					<pre><code class="scala">
libraryDependencies += 
  "com.typesafe.play" %% "play-json" % "2.6.9"
					</code></pre>
				</section>

				<section>
					<p>JsValue - алгебраический тип

					<ul>
						<li>JsArray
						<li>JsBoolean (JsTrue/JsFalse)
						<li>JsNumber
						<li>JsObject
						<li>JsString
						<li>JsNull
					</ul>
				</section>

				<section>
					<p>Запись JSON
					<pre><code class="scala">
import play.api.libs.json._

val v: JsValue = JsObject(Seq(
  "id" -> JsNumber(1),
  "name" -> JsString("Vasya"),
  "marks" -> JsArray(Seq(JsNumber(2), JsNumber(3)))
))

Json.stringify(v) // компактный формат
Json.prettyPrint(v) // с форматированием			
					</code></pre>
				</section>

				<section>
					<p>Большие структуры так выводить не удобно.

					<p class="fragment">Нужно разбить создание JSON на компоненты
					и комбинировать их.
				</section>

				<section>
					<p>Какие есть варианты?
				</section>

				<section>
					<p>Pattern matching?

					<p class="fragment">Не походит - мало операций,<br> много вариаций данных.
				</section>

				<section>
					<p>Объектный полиморфизм? Возможно

					<pre><code class="scala">
trait Writable {
  def toJson: JsValue
}					
					</code></pre>
				</section>

				<section>
					<p>Однако:

					<ul>
						<li class="fragment">trait не добавить к стандартным коллекциям
						<li class="fragment">trait не добавить к сторонним классам
						<li class="fragment">смешивается основная логика и доп. функции
					</ul>
				</section>

				<section>
					<p>Reflection? Да, это "Java-way".

					<p class="fragment">В runtime запрашиваем структуру объекта средствами JVM и выводим её.
				</section>

				<section>
					<p>Однако:

					<ul>
						<li class="fragment">Не типобезопасно: можно вывести что-то не то, например сессию БД или внутренний
						пароль
						<li class="fragment">Медленно
						<li class="fragment">Трудности с настройкой формата вывода
						<li class="fragment">Нельзя использовать контекст при выводе
				</section>

				<section>
					<p>Решение - тайпкласс, еще один вариант полиморфизма.
				</section>

				<section>
					<pre><code class="scala">
// упрощенный код
trait Writes[A] {
  def writes(o: A): JsValue
}
					</code></pre>
					<p>использование
					<pre><code class="scala">
def toJson[T](o: T)(implicit tjs: Writes[T]): JsValue = 
  tjs.writes(o)
					</code></pre>
				</section>

				<section>
					<p>Для примитивных типов готовая реализация

					<pre><code class="scala">
Json.toJson("some string")					
					</code></pre>
					<p>реализация
					<pre><code class="scala">
// из play-json
implicit object StringWrites extends Writes[String] {
  def writes(o: String) = JsString(o)
}
					</code></pre>
				</section>

				<section>
					<p>Для Seq нужно преобразование
					<pre><code class="scala">
implicit def traversableWrites[A](implicit w: Writes[A]): 
    Writes[Traversable[A]] = {

  Writes[Traversable[A]] { as =>
    val builder = mutable.ArrayBuilder.make[JsValue]()
    as.foreach { a =>
      builder += w.writes(a)
    }
    JsArray(builder.result())
  }
}

Json.toJson(Seq("some string", "second string"))
					</code></pre>
				</section>

				<section>
					<p>Для такой конструкции есть синтаксис
					<pre><code class="scala">
implicit def traversableWrites[A: Writes]: 
    Writes[Traversable[A]] = {
  val w = implicitly[Writes[A]]
  ...

// вместо
implicit def traversableWrites[A](implicit w: Writes[A]): 
    Writes[Traversable[A]]
					</code></pre>
				</section>

				<section>
					<p>Выводим case-класс
					<pre><code class="scala">import play.api.libs.json._

case class User(id: UUID, name: String, title: Option[String])

object User { // объявляем в companion object
  // OWrites вместо Writes
  // используем Writes.apply
  implicit val writes: OWrites[User] = OWrites { user ⇒
    Json.obj( // сам используем Writes для значений
      "id" -&gt; user.id,
      "name" -&gt; user.name,
      "title" -&gt; user.title 
    )
  }
} </code></pre>
				</section>

				<section>
					<p>Для простых случаев есть макрос
					<pre><code class="scala">
object User {
  implicit val writes: Writes[User] = Json.writes[User]
}					
					</code></pre>
				</section>

				<section>
					<p>Writes - не всегда простое преобразование
					<pre><code class="scala">
// writes зависит от языка пользователя
implicit def writes(implicit lang: Lang): Writes[User]
					</code></pre>
				</section>

				<section>
					<p>Такой полиморфизм работает в компиляторе, типы должны быть точно известны.
				</section>

				<section>
					<pre><code class="scala">
// один Writes для всего ADT
object Expr {
  implicit val writes: Writes[Expr] = Writes {
    case Number(value) ⇒ 
      JsNumber(value)
    case Plus(lhs, rhs) ⇒ 
      Json.obj("op" -&gt; "plus", "left" -&gt; lhs, "right" -&gt; rhs)
    case Minus(lhs, rhs) ⇒ 
      Json.obj("op" -&gt; "minus", "left" -&gt; lhs, "right" -&gt; rhs)
  }
}
					</code></pre>
				</section>

				<section>
					<p>Итого мы получили:
					<ul>
						<li>Специализированный код для каждого типа
						<li class="fragment">Типобезопасность
						<li class="fragment">Код записи JSON отделен от данных
						<li class="fragment">Возможности по кастомизации, использование контекста
					</ul>
				</section>

				<section>
					<p>Тайпклассы - популярный шаблон проектирования
				</section>

				<section>
					<h4>Чтение JSON и валидация
					<p>TODO
				</section>

				<section>
					<h4>Домашнее задание
					<p>TODO
				</section>

				<section>
					<h4>Доп: property based testing
					<p>TODO
				</section>

				<section>
					<p>Напоминаю:
					<ul>
						<li>Страничка курса: <a href="https://maxcom.github.io/scala-course/">https://maxcom.github.io/scala-course/</a>
						<li>Посещения - отмечаем на листочке
					</ul>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                controls: true,
                                progress: true,
                                history: true,
                                center: true,

                                transition: 'slide', // none/fade/slide/convex/concave/zoom

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
