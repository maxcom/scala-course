# Вопросы к зачету (1-4 дни)

1. Case-классы: зачем нужны и чем отличаются от обычных классов. 
   Зачем нужен extractor и как он применяется.
2. Алгебраические типы: зачем нужны; пример декларации. Выбор между полиморфизмом на методах и
   pattern matching.
3. Option[T]: как устроен; способы работы - pattern matching, map/flatMap, for
4. Обработка исключения при помощи try и Try. Отличия.
5. List[T]: устройство. Использование общих элементов структуры на примере вставки элемента в
   середину списка.
6. Обычная и хвостовая рекурсия. Как заменить рекурсию на цикл?
7. Основные операции над списками: map, flatMap, filter, collect. Что делают, пример на каждый метод.
8. Основные отличия List и Vector, сравнение эфективности операций вставки, доступа и декомпозации.
9. Vector: устройство, схема поиска элемента, схема вставки элемента в конец.
10. Stream. Устройство. Схема работы операции вставки элемента по заданому индексу.
11. Монады на примере Option. Как работает конструкция for ... yield
12. Тайпклассы: что это и зачем нужно. Как устроен тайпкласс.
13. Способы сериализации JSON. Тайпкласс или reflection, преимущества/недостатки.
14. Чтение JSON в Play-JSON. Императивный стиль (as/asOpt), через Reads и комбинация reads в
    монаду и аппликативный функтор.

# Вопросы к зачету (5-8 дни)

1. Конкурентный доступ к переменной: проблемы; разница между использованием блокировок, 
   volatile и atomic. Deadlock - как возникает и как его избегать.
2. Future и Promise. Что это такое; устройство, работа с callback'ами.
3. Трансформация Future. Основные операции; схема работы метода map
4. HTTP/1.1: базовое устройство протокола; основные методы; режимы передачи тела запроса/ответа
5. Неблокироющийся ввод-вывод и Event Loop: преимущества и проблемы; схема работы
6. Что такое актор? Основные компоненты актора; акторы и многопоточность
7. Работа с Future в акторе. Как сделать запрос и изменить состояние на основе ответа? Как сделать
   запрос и передать ответ отправителю?
8. CircuitBreaker: что это и какую проблему он решает. 
9. Взаимодействие акторов и back pressure. Какую проблему решаем; схема работы.
10. Akka Streams. Зачем нужны асинхронные потоки? Что такое Source, Sink, Flow и Materializer?

